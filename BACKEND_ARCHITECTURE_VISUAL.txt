UNISON MES BACKEND - ARCHITECTURE DIAGRAM
==========================================

REQUEST FLOW DIAGRAM:
=====================

HTTP Request
    ↓
[1. RequestIDMiddleware]
    ↓ Adds correlation ID
[2. AuthMiddleware]
    ↓ JWT validation + RLS context
[3. RateLimitMiddleware]
    ↓ Rate limiting check
[4. CORSMiddleware]
    ↓ CORS validation
[5. API Router Handler]
    ↓ Route to specific endpoint handler


PRESENTATION LAYER
==================
FastAPI App (main.py)
    ├── API Routes (v1)
    │   ├── /api/v1/auth/        → auth.py (login, refresh)
    │   ├── /api/v1/users/       → users.py (CRUD)
    │   ├── /api/v1/materials/   → materials.py
    │   ├── /api/v1/machines/    → machines.py
    │   ├── /api/v1/shifts/      → shifts.py
    │   ├── /api/v1/plants/      → plants.py
    │   ├── /api/v1/organizations/ → organizations.py
    │   ├── /api/v1/production-logs/ → production_logs.py
    │   ├── /api/v1/bom/         → bom.py
    │   ├── /api/v1/quality/     → quality.py
    │   ├── /api/v1/maintenance/ → maintenance.py
    │   ├── /api/v1/roles/       → roles.py
    │   ├── /api/v1/workflows/   → workflows.py
    │   ├── /api/v1/logistics/   → logistics.py
    │   ├── /api/v1/reporting/   → reporting.py
    │   ├── /api/v1/branding/    → branding.py
    │   └── /api/v1/infrastructure/ → infrastructure.py
    │
    ├── Middleware
    │   ├── auth_middleware.py (JWT + RLS context)
    │   ├── request_id_middleware.py (correlation)
    │   └── rate_limit_middleware.py (throttling)
    │
    └── Response Models (DTOs)


APPLICATION LAYER
=================
Use Cases + Services
    ├── Use Cases
    │   ├── user/ (create, get, update, delete)
    │   └── auth/ (login, refresh)
    │
    └── Services (20+ business logic services)
        ├── email_service.py
        ├── production_scheduling_service.py
        ├── material_search_service.py
        ├── barcode_service.py
        ├── rbac_service.py
        ├── reporting_service.py
        ├── mrp_service.py
        ├── logistics_service.py
        ├── workflow_service.py
        └── ... (10+ more)


DOMAIN LAYER
============
Pure Business Logic
    ├── Entities (25 files)
    │   ├── user.py
    │   ├── material.py
    │   ├── work_order.py
    │   ├── production_log.py
    │   ├── machine.py
    │   └── ... (20+ more)
    │
    ├── Domain Services (8 files)
    │   ├── bom_service.py
    │   ├── capacity_calculator.py
    │   ├── lot_sizing_service.py
    │   ├── scheduling_strategy_service.py
    │   └── currency/
    │
    ├── Value Objects
    │   ├── email.py
    │   └── username.py
    │
    ├── Repositories (Interfaces)
    │   └── user_repository.py
    │
    └── Exceptions
        └── domain_exception.py


INFRASTRUCTURE LAYER
====================
External Systems & Adapters
    ├── Database
    │   ├── rls.py (Row-Level Security)
    │   └── PostgreSQL session management
    │
    ├── Security
    │   ├── jwt_handler.py (JWT operations)
    │   ├── dependencies.py (Auth injection)
    │   ├── rbac_dependencies.py (RBAC)
    │   └── casbin_enforcer.py (Policy enforcement)
    │
    ├── Persistence
    │   ├── models.py (SQLAlchemy ORM)
    │   ├── user_repository_impl.py
    │   ├── mappers/
    │   └── 22+ other repositories
    │
    ├── Adapters
    │   └── sap/ (SAP ERP integration)
    │       ├── sap_client.py
    │       ├── material_adapter.py
    │       ├── inventory_adapter.py
    │       └── costing_adapter.py
    │
    ├── Storage
    │   ├── minio_client.py (S3-compatible)
    │   └── barcode_storage_service.py
    │
    ├── Messaging
    │   ├── pgmq_client.py (Message Queue)
    │   └── pgmq_tasks.py (Async tasks)
    │
    ├── Search
    │   ├── pg_search_service.py (Full-text search)
    │   └── search_config.py
    │
    ├── Email
    │   ├── config.py (Pluggable providers)
    │   └── templates/
    │
    └── Tasks
        ├── celery_app.py
        └── user_tasks.py


CORE LAYER
==========
Configuration & Setup
    ├── config.py (Settings/Environment)
    ├── database.py (SQLAlchemy setup)
    └── extensions.py (PostgreSQL extensions)


DATA FLOW DIAGRAM
=================

User Requests
    ↓
[API Gateway]
    ↓
[Middleware Stack]
    ├─ JWT Validation
    ├─ RLS Context Setting
    └─ Rate Limiting
    ↓
[API Route Handler]
    ↓
[Use Case / Service]
    ↓
[Domain Logic]
    ↓
[Repository]
    ↓
[SQLAlchemy ORM]
    ↓
[PostgreSQL Database]
    ├─ Core Tables
    ├─ Production Tables
    ├─ Quality Tables
    ├─ Material Tables
    └─ ... (28+ tables)
    ↓
[Response]
    ↓
[JSON Serialization]
    ↓
[HTTP Response to Client]


AUTHENTICATION FLOW
===================

1. User Login
   POST /api/v1/auth/login
   ├─ Email & Password
   └─ UserRepository validates credentials
   
2. JWT Token Generation
   JWTHandler creates:
   ├─ Access Token (30 min expiry)
   │  └─ Claims: sub, email, org_id, plant_id, exp, iat
   └─ Refresh Token (7 day expiry)

3. Protected Request
   GET /api/v1/users/
   ├─ Authorization: Bearer <access_token>
   ├─ AuthMiddleware validates JWT
   ├─ Extracts organization_id & plant_id
   └─ Sets RLS context in database session

4. Multi-Tenant Isolation
   RLS Policies enforce:
   ├─ app.current_organization_id (required)
   └─ app.current_plant_id (optional)


MULTI-TENANCY ARCHITECTURE
===========================

Organization Level
    │
    ├── Organization 1 (org_id=1)
    │   ├── Plant 1
    │   │   ├── Department A (RLS isolated)
    │   │   └── Department B (RLS isolated)
    │   └── Plant 2
    │       ├── Department C (RLS isolated)
    │       └── Department D (RLS isolated)
    │
    └── Organization 2 (org_id=2)
        ├── Plant 3
        │   ├── Department E (RLS isolated)
        │   └── Department F (RLS isolated)
        └── Plant 4
            └── Department G (RLS isolated)

Each organization has:
- Separate JWT claims (organization_id in token)
- RLS policies enforcing data isolation
- Optional plant-level segmentation
- Independent user roles & permissions


DATABASE SCHEMA STRUCTURE
=========================

PostgreSQL Database
├── Extensions
│   ├── uuid-ossp (UUID generation)
│   ├── timescaledb (Time-series data)
│   ├── pgcrypto (Encryption)
│   ├── pg_trgm (Fuzzy search)
│   └── pg_search (Full-text search)
│
├── Core Tables (Foundation)
│   ├── organizations (top-level tenant)
│   ├── users (system users)
│   ├── plants (manufacturing sites)
│   └── departments (functional units)
│
├── Production Tables
│   ├── machines
│   ├── work_orders
│   ├── production_logs
│   ├── shifts
│   ├── lanes
│   └── work_center_shifts
│
├── Materials & Inventory
│   ├── materials
│   ├── bom (Bill of Materials)
│   ├── inventory
│   └── unit_of_measure
│
├── Quality Management
│   ├── quality_records
│   ├── inspections
│   └── ncrs (Non-Conformance Reports)
│
├── Planning & Costing
│   ├── mrp_runs
│   ├── planned_orders
│   ├── costing
│   └── currencies
│
├── Projects & Workflows
│   ├── projects
│   ├── project_management
│   └── workflows
│
├── Organization & RBAC
│   ├── roles
│   ├── custom_fields
│   └── role_permissions
│
├── Traceability & Logistics
│   ├── traceability (lots, serials)
│   └── logistics (shipments, barcodes)
│
├── Reporting & Branding
│   ├── reporting (dashboards, reports)
│   ├── branding (white-label config)
│   └── infrastructure (audit, notifications, settings)
│
└── RLS Policies (53+ across 28+ tables)
    └─ Enforce tenant isolation per organization


INFRASTRUCTURE INTEGRATIONS
============================

1. PostgreSQL Database
   ├─ Primary data store
   ├─ RLS for security
   └─ 28+ tables with indexes

2. MinIO Object Storage
   ├─ S3-compatible API
   ├─ Barcode images
   ├─ Documents
   └─ File attachments

3. PostgreSQL Message Queue (PGMQ)
   ├─ 30K messages/sec throughput
   ├─ Async task processing
   └─ Replaces external message broker

4. PostgreSQL Search
   ├─ BM25 full-text search
   ├─ Material search indexing
   └─ Replaces Elasticsearch

5. SAP ERP Adapter
   ├─ Material master data sync
   ├─ Inventory integration
   ├─ Costing data
   └─ HTTP API communication

6. Email Service (Pluggable)
   ├─ SMTP provider
   ├─ SendGrid API
   ├─ AWS SES
   └─ Email templates

7. Celery Task Queue
   ├─ Redis backend
   ├─ Async processing
   └─ Task scheduling

8. Casbin RBAC Engine
   ├─ Policy enforcement
   ├─ Role-permission management
   └─ Dynamic permission checks


DEPLOYMENT ARCHITECTURE
=======================

                    [Client Browser]
                            ↓
                    [Load Balancer]
                            ↓
    ┌───────────────────────┼───────────────────────┐
    ↓                       ↓                       ↓
[FastAPI 1]          [FastAPI 2]            [FastAPI N]
    ↓                       ↓                       ↓
    └───────────────────────┼───────────────────────┘
                            ↓
                [Connection Pool]
                            ↓
                    [PostgreSQL]
                    ├─ Primary
                    └─ Replicas
                            ↓
                    ├─ Tables (28+)
                    ├─ RLS Policies (53+)
                    ├─ Indexes
                    └─ Extensions
                    
External Services:
    ├─ MinIO (File Storage)
    ├─ Redis (Cache/Queue)
    ├─ SAP (ERP Integration)
    ├─ SendGrid/AWS SES (Email)
    └─ SMTP (Email)


KEY ARCHITECTURAL PRINCIPLES
=============================

1. Clean Architecture
   ✓ Clear separation of concerns
   ✓ Independence of frameworks
   ✓ Testable business logic
   ✓ Domain-driven design

2. Multi-Tenancy
   ✓ Organization-level isolation
   ✓ RLS enforcement at database
   ✓ JWT claims carry org context
   ✓ Optional plant-level segmentation

3. Security
   ✓ JWT-based stateless auth
   ✓ Row-Level Security (RLS)
   ✓ RBAC via Casbin
   ✓ Password hashing with bcrypt
   ✓ Environment-based secrets

4. Scalability
   ✓ Stateless API servers
   ✓ Database connection pooling
   ✓ Message queue for async tasks
   ✓ Full-text search indexing
   ✓ Time-series data compression

5. Maintainability
   ✓ Dependency injection
   ✓ Repository pattern
   ✓ Service layer abstraction
   ✓ DTOs for API contracts
   ✓ Exception handling strategy

6. Extensibility
   ✓ Custom fields framework
   ✓ Pluggable email providers
   ✓ Adapter pattern for SAP
   ✓ Abstract interfaces


TECHNOLOGY CHOICES & RATIONALE
================================

FastAPI
  ✓ Modern async Python framework
  ✓ Auto-generated OpenAPI docs
  ✓ Built-in dependency injection
  ✓ High performance (comparable to Node.js)

PostgreSQL + Extensions
  ✓ ACID compliance
  ✓ Native RLS for security
  ✓ TimescaleDB for time-series
  ✓ PGMQ eliminates external message broker
  ✓ pg_search replaces Elasticsearch
  ✓ pg_duckdb for analytics acceleration

SQLAlchemy ORM
  ✓ Type-safe database access
  ✓ Migration support via Alembic
  ✓ Relationship management
  ✓ Query optimization

JWT Authentication
  ✓ Stateless (no session storage)
  ✓ Carries multi-tenant context
  ✓ Supports token refresh
  ✓ Standard across platforms

MinIO
  ✓ S3-compatible (AWS compatibility)
  ✓ Self-hosted option
  ✓ No vendor lock-in
  ✓ Open-source

Casbin RBAC
  ✓ Fine-grained access control
  ✓ Policy-based authorization
  ✓ Language-agnostic
  ✓ Supports multiple models

