"""
SQL Injection Vulnerability Test - CRITICAL ISSUE #2

Tests that search_materials() properly escapes LIKE special characters.

VULNERABLE CODE (material_repository.py:296, 306):
    search_pattern = f"%{query}%"  # NO ESCAPING!
    Material.material_number.ilike(search_pattern)

ATTACK VECTORS:
- Input: "%_%_%_%" -> DoS via expensive wildcard scan
- Input: "100%" -> Matches "100X", "1000", etc (wrong results)
- Input: "MAT_001" -> Matches "MATX001", "MAT0001", etc (wrong results)
"""
import pytest
import re


def vulnerable_search_pattern(query: str) -> str:
    """Current VULNERABLE implementation"""
    return f"%{query}%"


def secure_search_pattern(query: str) -> str:
    """FIXED implementation with proper escaping"""
    # Escape LIKE special characters: %, _, \
    query_escaped = query.replace('\\', '\\\\').replace('%', '\\%').replace('_', '\\_')
    return f"%{query_escaped}%"


class TestSQLInjectionVulnerability:
    """Demonstrate SQL injection vulnerability in search"""

    def test_vulnerable_allows_percent_wildcard(self):
        """FAILS: Current code allows % as wildcard when user meant literal %"""
        query = "100%"
        pattern = vulnerable_search_pattern(query)

        # Vulnerable: Creates pattern "%100%%" which matches MORE than intended
        assert pattern == "%100%%"

        # In SQL: WHERE column ILIKE '%100%%'
        # This matches: "100%", "100% Cotton", "1000%", "100 Percent", etc.
        # User wanted: Only literal "100%" string

    def test_vulnerable_allows_underscore_wildcard(self):
        """FAILS: Current code allows _ as wildcard when user meant literal _"""
        query = "MAT_001"
        pattern = vulnerable_search_pattern(query)

        # Vulnerable: Creates pattern "%MAT_001%" where _ is wildcard
        assert pattern == "%MAT_001%"

        # In SQL: WHERE column ILIKE '%MAT_001%'
        # This matches: "MAT_001", "MATX001", "MAT0001", etc.
        # User wanted: Only literal "MAT_001" string

    def test_vulnerable_allows_dos_attack(self):
        """FAILS: Malicious wildcards cause expensive query"""
        malicious_query = "%_%_%_%_%_%_%_"
        pattern = vulnerable_search_pattern(malicious_query)

        # Vulnerable: Creates catastrophic wildcard pattern
        assert pattern == "%%_%_%_%_%_%_%_%"

        # In SQL: WHERE column ILIKE '%%_%_%_%_%_%_%_%'
        # This causes EXPENSIVE full table scan with complex pattern matching
        # Potential DoS vulnerability

    def test_secure_escapes_percent_wildcard(self):
        """PASSES: Fixed code escapes % to literal character"""
        query = "100%"
        pattern = secure_search_pattern(query)

        # Secure: % is escaped as \%
        assert pattern == "%100\\%%"

        # In SQL with escape='\\': WHERE column ILIKE '%100\%%' ESCAPE '\\'
        # This matches ONLY: "100%" (literal percent sign)

    def test_secure_escapes_underscore_wildcard(self):
        """PASSES: Fixed code escapes _ to literal character"""
        query = "MAT_001"
        pattern = secure_search_pattern(query)

        # Secure: _ is escaped as \_
        assert pattern == "%MAT\\_001%"

        # In SQL with escape='\\': WHERE column ILIKE '%MAT\_001%' ESCAPE '\\'
        # This matches ONLY: "MAT_001" (literal underscore)

    def test_secure_prevents_dos_attack(self):
        """PASSES: Fixed code neutralizes malicious wildcards"""
        malicious_query = "%_%_%_%_%_%_%_"
        pattern = secure_search_pattern(malicious_query)

        # Secure: All special chars escaped (ends with \_ not %%)
        assert pattern == "%\\%\\_\\%\\_\\%\\_\\%\\_\\%\\_\\%\\_\\%\\_%"

        # In SQL with escape='\\': This is now a literal string search, not wildcard
        # No DoS risk - query completes quickly

    def test_secure_escapes_backslash(self):
        """PASSES: Fixed code escapes backslash to prevent escape bypass"""
        query = "C:\\Users"
        pattern = secure_search_pattern(query)

        # Secure: \ is escaped as \\
        assert pattern == "%C:\\\\Users%"

        # Prevents attack: "\" + "%" -> "\%" escaping our escape
        # Backslash must be escaped FIRST

    def test_integration_search_requires_escape_parameter(self):
        """
        CRITICAL: SQLAlchemy .ilike() requires escape parameter

        VULNERABLE:
            Material.material_name.ilike(search_pattern)

        SECURE:
            Material.material_name.ilike(search_pattern, escape='\\\\')
        """
        # This test documents the REQUIRED fix in material_repository.py:296-313

        vulnerable_code = """
        search_pattern = f"%{query}%"
        db_query.filter(
            or_(
                Material.material_number.ilike(search_pattern),
                Material.material_name.ilike(search_pattern),
                Material.description.ilike(search_pattern),
            )
        )
        """

        secure_code = """
        query_escaped = query.replace('\\\\', '\\\\\\\\').replace('%', '\\\\%').replace('_', '\\\\_')
        search_pattern = f"%{query_escaped}%"
        db_query.filter(
            or_(
                Material.material_number.ilike(search_pattern, escape='\\\\'),
                Material.material_name.ilike(search_pattern, escape='\\\\'),
                Material.description.ilike(search_pattern, escape='\\\\'),
            )
        )
        """

        # Test passes to document expected behavior
        assert True


class TestEscapeOrderMatters:
    """Backslash MUST be escaped first to prevent escape bypass"""

    def test_wrong_order_allows_bypass(self):
        """FAILS: Escaping % before \\ allows bypass"""
        query = "test\\%"

        # Wrong order: escape % first
        wrong = query.replace('%', '\\%').replace('\\', '\\\\')

        # Result: "test\\\%" (backslash doubled, % escaped)
        # In SQL: Matches "test\%" literally - WRONG!
        # User input had escaped %, not literal %

    def test_correct_order_prevents_bypass(self):
        """PASSES: Escaping \\ first prevents bypass"""
        query = "test\\%"

        # Correct order: escape \\ first
        correct = query.replace('\\', '\\\\').replace('%', '\\%')

        # Result: "test\\\\\\%" (both chars properly escaped)
        # In SQL: Matches "test\%" literally - CORRECT!
        assert correct == "test\\\\\\%"


# Evidence for code review
VULNERABLE_CODE_LOCATION = """
File: /Users/vivek/jet/unison/backend/app/infrastructure/repositories/material_repository.py
Lines: 296-313

VULNERABLE CODE (appears TWICE):
    search_pattern = f"%{query}%"
    db_query = db_query.filter(
        or_(
            Material.material_number.ilike(search_pattern),
            Material.material_name.ilike(search_pattern),
            Material.description.ilike(search_pattern),
        )
    )

REQUIRED FIX:
    # Escape LIKE special characters before interpolation
    query_escaped = query.replace('\\\\', '\\\\\\\\').replace('%', '\\\\%').replace('_', '\\\\_')
    search_pattern = f"%{query_escaped}%"

    db_query = db_query.filter(
        or_(
            Material.material_number.ilike(search_pattern, escape='\\\\'),
            Material.material_name.ilike(search_pattern, escape='\\\\'),
            Material.description.ilike(search_pattern, escape='\\\\'),
        )
    )

IMPACT:
- DoS: Malicious wildcards cause expensive table scans
- Wrong results: User search for "100%" matches "1000", "100 items", etc
- Data leakage: Attacker can fish for material numbers via wildcard probing
"""
