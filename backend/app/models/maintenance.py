"""
SQLAlchemy models for Maintenance Management domain.
"""
from sqlalchemy import Column, Integer, String, Boolean, DateTime, Float, ForeignKey, Enum, Index, Text, UniqueConstraint, CheckConstraint
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from app.core.database import Base
from app.domain.entities.maintenance import TriggerType, PMStatus, DowntimeCategory


class PMSchedule(Base):
    """
    PM Schedule entity - preventive maintenance schedules.

    Supports multi-tenant isolation via organization_id and plant_id (RLS).
    Supports both calendar-based (time) and meter-based (usage) triggers.
    """
    __tablename__ = "pm_schedule"

    id = Column(Integer, primary_key=True, index=True)
    organization_id = Column(Integer, nullable=False, index=True)
    plant_id = Column(Integer, nullable=False, index=True)
    schedule_code = Column(String(50), nullable=False, index=True)
    schedule_name = Column(String(200), nullable=False)
    machine_id = Column(Integer, ForeignKey('machine.id', ondelete='CASCADE'), nullable=False, index=True)
    trigger_type = Column(Enum(TriggerType), nullable=False)
    frequency_days = Column(Integer, nullable=True)  # For CALENDAR trigger
    meter_threshold = Column(Float, nullable=True)  # For METER trigger
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    # Relationships
    pm_work_orders = relationship("PMWorkOrder", back_populates="pm_schedule", cascade="all, delete-orphan")

    # Constraints
    __table_args__ = (
        UniqueConstraint('organization_id', 'plant_id', 'schedule_code',
                         name='uq_pm_schedule_code_per_plant'),
        Index('idx_pm_schedule_org_plant', 'organization_id', 'plant_id'),
        Index('idx_pm_schedule_machine', 'machine_id'),
        Index('idx_pm_schedule_active', 'is_active'),
        CheckConstraint("(trigger_type = 'CALENDAR' AND frequency_days IS NOT NULL) OR (trigger_type = 'METER' AND meter_threshold IS NOT NULL)",
                       name='check_pm_schedule_trigger_requirements'),
    )

    def __repr__(self):
        return f"<PMSchedule(code='{self.schedule_code}', type='{self.trigger_type}', org={self.organization_id})>"


class PMWorkOrder(Base):
    """
    PM Work Order entity - auto-generated preventive maintenance tasks.

    Supports multi-tenant isolation via organization_id and plant_id (RLS).
    Auto-generated by pg_cron job based on PM schedules.
    """
    __tablename__ = "pm_work_order"

    id = Column(Integer, primary_key=True, index=True)
    organization_id = Column(Integer, nullable=False, index=True)
    plant_id = Column(Integer, nullable=False, index=True)
    pm_schedule_id = Column(Integer, ForeignKey('pm_schedule.id', ondelete='CASCADE'), nullable=False, index=True)
    machine_id = Column(Integer, ForeignKey('machine.id', ondelete='CASCADE'), nullable=False, index=True)
    pm_number = Column(String(50), nullable=False, index=True)
    status = Column(Enum(PMStatus), nullable=False, default=PMStatus.SCHEDULED, index=True)
    scheduled_date = Column(DateTime(timezone=True), nullable=False)
    due_date = Column(DateTime(timezone=True), nullable=False)
    started_at = Column(DateTime(timezone=True), nullable=True)
    completed_at = Column(DateTime(timezone=True), nullable=True)
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    # Relationships
    pm_schedule = relationship("PMSchedule", back_populates="pm_work_orders")

    # Constraints
    __table_args__ = (
        UniqueConstraint('organization_id', 'plant_id', 'pm_number',
                         name='uq_pm_work_order_number_per_plant'),
        Index('idx_pm_work_order_org_plant', 'organization_id', 'plant_id'),
        Index('idx_pm_work_order_schedule', 'pm_schedule_id'),
        Index('idx_pm_work_order_machine', 'machine_id'),
        Index('idx_pm_work_order_status', 'status'),
        Index('idx_pm_work_order_scheduled_date', 'scheduled_date'),
    )

    def __repr__(self):
        return f"<PMWorkOrder(number='{self.pm_number}', status='{self.status}', org={self.organization_id})>"


class DowntimeEvent(Base):
    """
    Downtime Event entity - tracks equipment downtime incidents.

    Supports multi-tenant isolation via organization_id and plant_id (RLS).
    Used for MTBF/MTTR calculations and OEE reporting.
    Should be converted to TimescaleDB hypertable for time-series efficiency.
    """
    __tablename__ = "downtime_event"

    id = Column(Integer, primary_key=True, index=True)
    organization_id = Column(Integer, nullable=False, index=True)
    plant_id = Column(Integer, nullable=False, index=True)
    machine_id = Column(Integer, ForeignKey('machine.id', ondelete='CASCADE'), nullable=False, index=True)
    category = Column(Enum(DowntimeCategory), nullable=False, index=True)
    reason = Column(String(500), nullable=False)
    started_at = Column(DateTime(timezone=True), nullable=False, index=True)
    ended_at = Column(DateTime(timezone=True), nullable=True, index=True)
    notes = Column(Text, nullable=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    # Indexes for time-series queries and RLS
    __table_args__ = (
        Index('idx_downtime_event_org_plant', 'organization_id', 'plant_id'),
        Index('idx_downtime_event_machine', 'machine_id'),
        Index('idx_downtime_event_category', 'category'),
        Index('idx_downtime_event_time_range', 'started_at', 'ended_at'),
        Index('idx_downtime_event_machine_time', 'machine_id', 'started_at'),
    )

    def __repr__(self):
        duration = (self.ended_at - self.started_at).total_seconds() / 60.0 if self.ended_at else None
        return f"<DowntimeEvent(machine_id={self.machine_id}, category='{self.category}', duration={duration}min)>"
