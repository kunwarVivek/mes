# Maintenance Management Domain

**Domain**: Maintenance Management (MES Module)
**Bounded Context**: Preventive Maintenance Scheduling, Downtime Tracking, Equipment Reliability
**Owner**: Maintenance & Engineering
**Status**: Supporting Domain (Medium Strategic Importance)

---

## Domain Overview

### Purpose

The Maintenance Management domain ensures equipment reliability through preventive maintenance (PM) scheduling, downtime tracking, and reliability metrics (MTBF/MTTR). It minimizes unplanned downtime and extends equipment lifespan through systematic maintenance planning.

### Scope

**In Scope**:
- Preventive Maintenance (PM) schedules (calendar-based and meter-based)
- PM work order generation (auto-generated via pg_cron)
- PM work order execution tracking
- Downtime event recording and categorization
- MTBF (Mean Time Between Failures) calculation
- MTTR (Mean Time To Repair) calculation
- Downtime Pareto analysis (top causes)
- Maintenance calendar view

**Out of Scope**:
- Equipment/machine master data → Equipment domain
- Spare parts inventory → Material domain
- Maintenance cost tracking → Financial reporting (future)

### Key Business Goals

1. **Reduce Unplanned Downtime**: 80% preventive vs 20% reactive maintenance
2. **Equipment Reliability**: MTBF >500 hours for critical equipment
3. **Fast Response**: MTTR <4 hours for critical equipment
4. **PM Compliance**: 95%+ PM tasks completed on time
5. **Proactive Planning**: Auto-generate PM work orders 7 days before due date

---

## Core Concepts

### Preventive Maintenance (PM) Schedule

**Definition**: A recurring maintenance task for a specific machine (e.g., "Lubricate bearings every 30 days" or "Calibrate after 1000 operating hours").

**Frequency Types**:
- **calendar**: Time-based (every N days/weeks/months)
- **meter**: Usage-based (every N operating hours or cycles)

**PM Types**:
- **inspection**: Visual/functional inspection
- **lubrication**: Oil/grease application
- **calibration**: Measurement accuracy verification
- **parts_replacement**: Replace wear parts (filters, belts, bearings)

**Schedule Structure**:
```python
schedule = {
    "machine_id": 5,
    "pm_type": "lubrication",
    "frequency_type": "calendar",
    "frequency_value": 30,
    "frequency_unit": "days",
    "lead_time_days": 7,  # Generate WO 7 days before due
    "estimated_duration_hours": 2.0,
    "task_checklist": [
        "Inspect bearing condition",
        "Apply lithium grease to all bearings",
        "Check for unusual noise/vibration"
    ],
    "last_pm_date": "2025-10-15",
    "next_due_date": "2025-11-14"  # 30 days after last PM
}
```

### PM Work Order

**Definition**: An executable work order for a specific PM task, auto-generated by pg_cron or manually created.

**Lifecycle**:
```
planned → in_progress → completed
            ↓
       (cancelled)
```

**Auto-Generation Logic** (pg_cron):
```sql
-- Run daily at 6 AM
SELECT cron.schedule(
    'pm-work-order-generation',
    '0 6 * * *',
    $$
    INSERT INTO pm_work_orders (organization_id, work_order_number, pm_schedule_id, machine_id, scheduled_date)
    SELECT
        ps.organization_id,
        'PM-' || TO_CHAR(NOW(), 'YYYY-MM-DD') || '-' || LPAD(ps.id::TEXT, 4, '0'),
        ps.id,
        ps.machine_id,
        ps.next_due_date
    FROM pm_schedules ps
    WHERE ps.is_active = TRUE
    AND ps.next_due_date <= CURRENT_DATE + ps.lead_time_days
    AND NOT EXISTS (
        SELECT 1 FROM pm_work_orders pwo
        WHERE pwo.pm_schedule_id = ps.id
        AND pwo.status IN ('planned', 'in_progress')
    );
    $$
);
```

**Overdue Detection** (PostgreSQL GENERATED column):
```sql
is_overdue BOOLEAN GENERATED ALWAYS AS (
    CASE WHEN status IN ('planned', 'in_progress') AND scheduled_date < CURRENT_DATE
    THEN TRUE ELSE FALSE END
) STORED
```

### Downtime Event

**Definition**: A period when a machine is unavailable for production (breakdown, maintenance, setup, etc.).

**Downtime Categories**:
- **equipment**: Mechanical/electrical failure
- **material**: Material shortage or defect
- **quality**: Quality issue stops production
- **setup**: Changeover or setup time
- **process**: Process issue (e.g., software crash)

**Downtime Reasons** (equipment category):
```python
DOWNTIME_REASONS = {
    "mechanical_failure": "Bearing seized, motor failed, etc.",
    "electrical_failure": "Sensor failure, PLC issue, etc.",
    "hydraulic_failure": "Pump failure, leak, etc.",
    "tooling_issue": "Tool breakage, wear",
    "preventive_maintenance": "Scheduled PM work",
    "operator_error": "Incorrect setup, wrong program"
}
```

**Duration Calculation**:
```python
# Auto-calculated when ended_at is set
duration_minutes = (ended_at - started_at).total_seconds() / 60

# Example:
# Started: 2025-11-07 10:00
# Ended: 2025-11-07 12:30
# Duration: 150 minutes
```

### MTBF (Mean Time Between Failures)

**Definition**: Average operating time between equipment failures (higher is better).

**Calculation**:
```python
mtbf = total_operating_hours / number_of_failures

# Example:
# Operating hours: 2000 hours
# Failures: 8
# MTBF = 250 hours
```

**pg_duckdb Query** (for analytics):
```sql
SELECT
    machine_id,
    COUNT(*) AS failure_count,
    SUM(duration_minutes) / 60.0 AS total_downtime_hours,
    (24 * 30 - SUM(duration_minutes) / 60.0) / COUNT(*) AS mtbf_hours
FROM downtime_events
WHERE downtime_category = 'equipment'
AND started_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY machine_id;
```

### MTTR (Mean Time To Repair)

**Definition**: Average time to repair a failure (lower is better).

**Calculation**:
```python
mttr = total_repair_time / number_of_failures

# Example:
# Total repair time: 32 hours
# Failures: 8
# MTTR = 4 hours
```

---

## Database Schema

### Tables (3 core tables)

See [DATABASE_SCHEMA.md](../02-architecture/DATABASE_SCHEMA.md) for full DDL.

#### 1. pm_schedules

Recurring maintenance task definitions.

**Key Columns**:
- `machine_id`: FK to machines
- `pm_type`: Enum (inspection, lubrication, calibration, parts_replacement)
- `frequency_type`: Enum (calendar, meter)
- `frequency_value`: Integer (30 days, 1000 hours)
- `frequency_unit`: Enum (days, weeks, months, hours, cycles)
- `lead_time_days`: Generate WO this many days before due (default 7)
- `estimated_duration_hours`: Estimated PM duration
- `task_checklist`: JSONB (checklist items)
- `last_pm_date`: Last PM completion date
- `next_due_date`: Next PM due date (updated after PM completion)
- `last_meter_value`: For meter-based schedules

**pg_cron Auto-Generation**: Creates pm_work_orders 7 days before next_due_date

#### 2. pm_work_orders

Executable PM work orders.

**Key Columns**:
- `work_order_number`: Unique (e.g., "PM-2025-11-07-0001")
- `pm_schedule_id`: FK to pm_schedules
- `machine_id`: FK to machines
- `status`: Enum (planned, in_progress, completed, cancelled)
- `scheduled_date`: Target completion date
- `started_at`: Actual start timestamp
- `completed_at`: Actual completion timestamp
- `checklist_completion`: JSONB (completed tasks)
- `completion_notes`: Technician notes
- `assigned_technician_id`: FK to users
- `performed_by`: FK to users (who completed)
- `is_overdue`: GENERATED column (TRUE if past scheduled_date and not completed)

**LISTEN/NOTIFY Trigger** (overdue PM alerts):
```sql
CREATE OR REPLACE FUNCTION notify_overdue_pm() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.is_overdue = TRUE THEN
        PERFORM pg_notify('overdue_pm_alert',
            json_build_object(
                'pm_work_order_id', NEW.id,
                'work_order_number', NEW.work_order_number,
                'machine_id', NEW.machine_id,
                'scheduled_date', NEW.scheduled_date
            )::text
        );
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

#### 3. downtime_events

Machine downtime event log (timescaledb hypertable).

**Key Columns**:
- `machine_id`: FK to machines
- `work_order_id`: FK to work_orders (if downtime during production)
- `downtime_reason_code`: Enum (mechanical_failure, electrical_failure, etc.)
- `downtime_category`: Enum (equipment, material, quality, setup, process)
- `started_at`: Downtime start timestamp
- `ended_at`: Downtime end timestamp (NULL if ongoing)
- `duration_minutes`: Calculated when ended_at is set
- `resolution_notes`: How the issue was resolved
- `reported_by`: FK to users
- `resolved_by`: FK to users

**timescaledb Hypertable**:
```sql
SELECT create_hypertable('downtime_events', 'started_at',
    chunk_time_interval => INTERVAL '1 month'
);

-- Compression after 7 days
ALTER TABLE downtime_events SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'organization_id, machine_id'
);
SELECT add_compression_policy('downtime_events', INTERVAL '7 days');

-- 2-year retention
SELECT add_retention_policy('downtime_events', INTERVAL '2 years');
```

**Continuous Aggregate** (daily downtime summary):
```sql
CREATE MATERIALIZED VIEW daily_downtime_summary
WITH (timescaledb.continuous) AS
SELECT
    time_bucket('1 day', started_at) AS day,
    organization_id,
    machine_id,
    downtime_category,
    COUNT(*) AS event_count,
    SUM(duration_minutes) AS total_downtime_minutes
FROM downtime_events
WHERE duration_minutes IS NOT NULL
GROUP BY day, organization_id, machine_id, downtime_category
WITH NO DATA;

SELECT add_continuous_aggregate_policy('daily_downtime_summary',
    start_offset => INTERVAL '7 days',
    end_offset => INTERVAL '1 hour',
    schedule_interval => INTERVAL '1 hour'
);
```

---

## Business Rules

### BR-MAINT-001: PM Work Order Auto-Generation

**Rule**: PM work orders are automatically generated by pg_cron when `next_due_date <= CURRENT_DATE + lead_time_days`.

**Implementation**: pg_cron job runs daily at 6 AM (see Auto-Generation Logic above)

### BR-MAINT-002: Update Next Due Date After PM Completion

**Rule**: When a PM work order is completed, update the parent PM schedule's `next_due_date` and `last_pm_date`.

**Implementation**:
```python
class CompletePMWorkOrderUseCase:
    def execute(self, pm_wo_id: int, dto: CompletePMDTO) -> PMWorkOrder:
        pm_wo = self.pm_wo_repo.find_by_id(pm_wo_id)
        pm_schedule = self.pm_schedule_repo.find_by_id(pm_wo.pm_schedule_id)

        # Complete PM work order
        pm_wo.status = PMWorkOrderStatus.COMPLETED
        pm_wo.completed_at = datetime.utcnow()
        pm_wo.performed_by = dto.performed_by
        pm_wo.checklist_completion = dto.checklist_completion

        # Update PM schedule
        pm_schedule.last_pm_date = datetime.utcnow().date()
        pm_schedule.next_due_date = self._calculate_next_due_date(pm_schedule)

        return self.pm_wo_repo.save(pm_wo)

    def _calculate_next_due_date(self, schedule: PMSchedule) -> date:
        if schedule.frequency_type == FrequencyType.CALENDAR:
            return schedule.last_pm_date + timedelta(
                days=schedule.frequency_value * self._get_days_multiplier(schedule.frequency_unit)
            )
        else:  # meter-based
            # Next PM when meter reaches: current_value + frequency_value
            return None  # Calculated when meter reading updated
```

### BR-MAINT-003: Downtime Duration Auto-Calculation

**Rule**: Downtime `duration_minutes` is automatically calculated when `ended_at` is set.

**Implementation** (PostgreSQL trigger):
```sql
CREATE OR REPLACE FUNCTION calculate_downtime_duration() RETURNS TRIGGER AS $$
BEGIN
    IF NEW.ended_at IS NOT NULL AND OLD.ended_at IS NULL THEN
        NEW.duration_minutes := EXTRACT(EPOCH FROM (NEW.ended_at - NEW.started_at)) / 60;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER downtime_duration_calc
BEFORE UPDATE ON downtime_events
FOR EACH ROW EXECUTE FUNCTION calculate_downtime_duration();
```

---

## Use Cases

### UC-MAINT-001: Create PM Schedule

**Actor**: Maintenance Manager

**Preconditions**: Machine exists

**Flow**:
1. Manager defines PM schedule (type, frequency, checklist)
2. System calculates initial next_due_date
3. System creates PM schedule record
4. pg_cron will auto-generate PM work orders 7 days before due

**API**: `POST /api/v1/pm-schedules`

### UC-MAINT-002: Complete PM Work Order

**Actor**: Maintenance Technician

**Preconditions**: PM WO assigned to technician

**Flow**:
1. Technician completes PM checklist
2. Technician records completion notes
3. System updates PM WO status='completed'
4. System updates PM schedule next_due_date (BR-MAINT-002)
5. System updates machine.last_maintenance_date

**API**: `POST /api/v1/pm-work-orders/{id}/complete`

### UC-MAINT-003: Record Downtime Event

**Actor**: Operator, Maintenance Technician

**Preconditions**: Machine stopped due to failure/issue

**Flow**:
1. User records downtime start (reason, category)
2. System creates downtime_event with started_at
3. User records downtime end when resolved
4. System calculates duration_minutes (BR-MAINT-003)
5. System triggers LISTEN/NOTIFY for real-time OEE update

**API**: `POST /api/v1/downtime-events`, `PUT /api/v1/downtime-events/{id}/end`

### UC-MAINT-004: View Maintenance Metrics (MTBF/MTTR)

**Actor**: Maintenance Manager, Plant Manager

**Preconditions**: Downtime events recorded

**Flow**:
1. User requests maintenance metrics for plant/date range
2. System queries timescaledb continuous aggregate
3. System calculates MTBF, MTTR, downtime by category
4. System returns metrics with Pareto chart data

**API**: `GET /api/v1/maintenance-metrics?plant_id=1&from=2025-10-01&to=2025-11-07`

---

## API Endpoints

See [API_DESIGN.md](../02-architecture/API_DESIGN.md) for complete specifications.

### Maintenance Endpoints (10 total)

| Method | Endpoint | Description |
|--------|----------|-------------|
| POST | `/api/v1/pm-schedules` | Create PM schedule |
| GET | `/api/v1/pm-schedules` | List PM schedules (by machine) |
| PUT | `/api/v1/pm-schedules/{id}` | Update PM schedule |
| GET | `/api/v1/pm-work-orders` | List PM work orders (filterable) |
| GET | `/api/v1/pm-work-orders/{id}` | Get PM WO details |
| POST | `/api/v1/pm-work-orders/{id}/start` | Start PM work order |
| POST | `/api/v1/pm-work-orders/{id}/complete` | Complete PM work order |
| POST | `/api/v1/downtime-events` | Record downtime event |
| PUT | `/api/v1/downtime-events/{id}/end` | End downtime event |
| GET | `/api/v1/maintenance-metrics` | Get MTBF/MTTR/Pareto |

---

## PostgreSQL-Native Features

### 1. pg_cron for PM Work Order Auto-Generation

**Purpose**: Automated PM work order creation (replaces Celery Beat)

**Performance**: Native PostgreSQL, no external services required

### 2. timescaledb Hypertable (downtime_events)

**Purpose**: Time-series optimization for downtime history

**Query Performance**: 10x faster queries with 75% compression

### 3. LISTEN/NOTIFY for Overdue PM Alerts

**Purpose**: Real-time notifications for overdue PM work orders

### 4. PostgreSQL GENERATED Column (is_overdue)

**Purpose**: Auto-calculated overdue status (no application logic required)

---

## Summary

The Maintenance Management domain ensures equipment reliability through PM scheduling and downtime tracking. Key features:

- **pg_cron**: Auto-generate PM work orders 7 days before due
- **timescaledb**: 10x faster downtime queries with 75% compression
- **GENERATED column**: Auto-calculate overdue status
- **LISTEN/NOTIFY**: Real-time overdue PM alerts

**Targets**:
- PM Compliance: >95% completed on time
- MTBF: >500 hours (critical equipment)
- MTTR: <4 hours (critical equipment)
- Downtime Reduction: 20% year-over-year

**Next Domain**: [EQUIPMENT_MACHINES.md](./EQUIPMENT_MACHINES.md)
